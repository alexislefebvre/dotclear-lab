<?php
# -- BEGIN LICENSE BLOCK ----------------------------------
# This file is part of soCialMe, a plugin for Dotclear 2.
# 
# Copyright (c) 2009-2011 JC Denis and contributors
# jcdenis@gdwd.com
# 
# Licensed under the GPL version 2.0 license.
# A copy of this license is available in LICENSE file or at
# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# -- END LICENSE BLOCK ------------------------------------
if (!defined('DC_RC_PATH')){return;}# All parts (sharer,reader,profil,writer) extend this classclass soCialMe{	public $core;		protected $ns = null;		protected $services = array();	protected $available = array();	protected $actions = array();	protected $markers = array();	protected $things = array();		# Load all services class and part markers	public function __construct($core)	{		if (!$this->ns) {			throw new Exception('Behavior name must be specified');		}				$this->core = $core;				# Load services list from behavior		$list = $core->getBehaviors($this->ns.'Service');				if (!empty($list))		{			foreach($list as $k => $callback)			{				try				{					list($service_id,$service_class) = call_user_func($callback);										$service = new $service_class($core);										if (!$service->available()) continue;										$this->services[$service_id] = $service;					$this->available[] = $service_id;										foreach($service->actions() as $action => $value)					{						if (!$value) continue;												$this->actions[$action][] = $service_id;					}				}				catch (Exception $e) {}			}		}				$this->init();				# Load part markers		$rs = new ArrayObject($this->markers);				$this->core->callBehavior($this->ns.'Marker',$rs);				$markers = $rs->getArrayCopy();				if (!is_array($markers)) $markers = array();				# Clean up default values		foreach($markers as $key => $marker)		{			$markers[$key] = array_merge(				array(					'name' => 'unknow',					'description' => 'no description',					'action' => array(),					'title' => false,					'page' => false				),				$marker			);		}		$this->markers = $markers;	}		# init for child class	protected function init()	{			}		# Return array of original markers	public function getMarkers()	{		return $this->markers;	}		# Return markers of a $type fill with original markers	public function getMarker($type='',$default='')	{		$partials = @unserialize(base64_decode($this->core->blog->settings->{$this->ns}->{$type}));		if (!is_array($partials)) $patials = array();				$rs = array();		foreach($this->markers as $key => $marker)		{			if (!isset($marker[$type])) continue;						if (!isset($partials[$key])) $partials[$key] = array();						if (is_array($marker[$type]))			{				foreach($marker[$type] as $t)				{					$rs[$key][$t] = isset($partials[$key][$t]) ? $partials[$key][$t] : $default;				}			}			elseif (true === $marker[$type])			{				$rs[$key] = isset($partials[$key]) ? $partials[$key] : $default;			}		}		return $rs;	}		# Reorder things array from a partial ordered array and a full unordered array	public function fillOrder($availables,$limit=false)	{		$partials = @unserialize(base64_decode($this->core->blog->settings->{$this->ns}->order));		if (!is_array($partials)) $partials = array();				$rs = array();		foreach($this->things as $thing => $plop)		{			$rs[$thing] = array();						# Clean partial array			if (!isset($partials[$thing]) || !is_array($partials[$thing])) {				$partials[$thing] = array();			}			$partials[$thing] = array_values($partials[$thing]);						# Clean available array			if (!isset($availables[$thing]) || !is_array($availables[$thing])) {				$availables[$thing] = array();			}			$availables[$thing] = array_values($availables[$thing]);						if ($limit) {				# Limit array to usable things				$partials[$thing] = array_intersect($partials[$thing],$availables[$thing]);			}			# Merge arrays and keep ordered services at first			$rs[$thing] = array_merge($partials[$thing],$availables[$thing]);						# Removed duplicate services			$rs[$thing] = array_unique($rs[$thing]);						# Clean keys			$rs[$thing] = array_values($rs[$thing]);		}		return $rs;	}		# Return array of services objects or one service	public function services($id='')	{		if (empty($id)) {			return $this->services;		}		elseif (!empty($id) && isset($this->services[$id])) {			return $this->services[$id];		}		else {			return array();		}	}		# Return array of id of available services	public function available()	{		return $this->available;	}		# Return array of id/name of available things	public function things()	{		return $this->things;	}		# return an array of id of available services for an action	public function can()	{		if (func_num_args() < 1) return array();				$actions = func_get_args();				$rs = array();		foreach($actions as $action)		{			$func = 'play'.$action;						if (!isset($this->actions[$func])) continue;						$rs = array_merge($rs,$this->actions[$func]);		}		return array_unique($rs);	}		# Execute action on service	public function play()	{		$n = func_num_args();		if ($n < 3) return false;				$args = func_get_args();		$service_id = array_shift($args);		$func = 'play'.array_shift($args).array_shift($args); // parseThingType($args)				if (!in_array($service_id,$this->actions[$func])) return false;				try {			return call_user_func_array(array($this->services[$service_id],$func),$args);		}		catch(Exception $e) { }				return false;	}}?>