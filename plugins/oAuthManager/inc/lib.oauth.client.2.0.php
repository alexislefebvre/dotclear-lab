<?php
# -- BEGIN LICENSE BLOCK ----------------------------------
# This file is part of oAuthManager, a plugin for Dotclear 2.
# 
# Copyright (c) 2009-2011 JC Denis and contributors
# jcdenis@gdwd.com
# 
# Licensed under the GPL version 2.0 license.
# A copy of this license is available in LICENSE file or at
# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# -- END LICENSE BLOCK ------------------------------------

if (!defined('DC_RC_PATH')){return;}class oAuthClient20{	/*	 * Client info	 */		protected $config;	protected $store;	protected $record;		/*	 * Queries	 */		#Contains the last HTTP status code returned	public $http_code;	#Contains the last HTTP headers returned	public $http_info;	# Contains the last API call	public $http_url;	# Set the useragnet	public $useragent = 'Dotclear-oAuthClientManager';	# Set timeout default	public $timeout = 30;	# Set connect timeout	public $connecttimeout = 30;	# Verify SSL Cert	public $ssl_verifypeer = true;	# Response format	public $format = 'json';	# Decode returned json data	public $decode_json = true;		/*	 * oAuth	 */	protected $oauth = null;//	protected $consumer = null;	protected $client = null;	protected $params = array();		public function __construct($core,$config)	{		# config: default values		$default = array(			# dotclear info			'plugin_id' => 'unknow',			'plugin_name' => __('Unknow'),			'client_id' => 'unknow',			'client_name' => __('Unknow'),			'user_id' => null,						# consumer info			'token' => null,			'secret' => null,			'api_url' => 'https://localhost/api',			'authorize' => 'https://localhost/oauth/authorize',			'access_token' => 'https://localhost/oauth/access_token',			'expiry' => null,			'options' => null,			'response_type' => 'code',			'query_type' => 'oauth_token' //could be access_token (facebook)		);		# config: current service		$this->config = array_merge($default,$config);				# storage		$this->store = new oAuthClientStore($core);				# consumer info		$this->consumer = array('token'=>$this->config['token'],'secret'=>$this->config['secret']);				# load start values		$this->reset();	}		public function reset()	{		# load user info if exists		$this->record = $this->store->get($this->config['plugin_id'],$this->config['client_id'],$this->config['user_id']);		# else add him		if (!$this->record) {			$this->record = $this->store->add($this->config['plugin_id'],$this->config['client_id'],$this->config['user_id']);		}				# if user previously registered: load client object		$this->client = 2 == $this->state() ? $this->record->token : null;	}		public function config($k)	{		return isset($this->config[$k]) ? $this->config[$k] : null;	}		public function state()	{		return !$this->record ? 0 : (integer) $this->record->state;	}		public function deleteRecord()	{		$this->store->del($this->record->uid);		$this->reset();	}		public function removeToken()	{		# update storage		$cur = $this->store->open();		$cur->state = 0;		$cur->token = null;		$this->store->upd($this->record->uid,$cur);				$this->reset();	}		public function getRequestToken($callback_url)	{		$params = array(			'client_id' => $this->config['token'], 		    'redirect_uri' => $callback_url		);		$params = array_merge($this->config['options'],$params);				$url = $this->config['authorize'].'?'.http_build_query($params,null,'&');				# update storage		$cur = $this->store->open();		$this->record->state = $cur->state = 1;		$this->record->token = $cur->token = null;		$this->record->secret = $cur->secret = null;		$this->store->upd($this->record->uid,$cur);				# redirect to next step		http::redirect($url);	}		public function getAccessToken($callback_url='',$response_format='')	{		if (1 != $this->state())		{			throw new Exception('Failed to get access, make request first');		}				# get returned token		$response_type = isset($_REQUEST[$this->config['response_type']]) ? $_REQUEST[$this->config['response_type']] : '';				# expired		if (empty($response_type))		{			throw new Exception('No code returned');		}				# check server token		$grant_type = empty($callback_url) ? 'refresh_token' : 'authorization_code';		$params = array(			'grant_type' => $grant_type,			'client_id' => $this->consumer['token'],			'client_secret' => $this->consumer['secret']		);				if ($grant_type == 'authorization_code')		{			$params[$this->config['response_type']] = $response_type; //code = token			$params['redirect_uri'] = $callback_url;		}		else		{			$params['refresh_token'] = $response_type;		}				$response = $this->query($this->config['access_token'],'POST',$params);				if ($this->http_code != 200)		{			throw new Exception(__('Failed to grant access: '.$this->http_info));		}		//reponse format on grant_access could be different from default response format		if ($response_format == 'json') 		{			$obj = json_decode($response);		}		else		{			parse_str($response,$r);			$obj = (object) $r;		}				if (!$obj)		{			throw new Exception('No token returned');		}				# client object		$this->client = $obj->access_token;				if ($obj->expires) {			$this->config['expiry'] = time() + (integer) $obj->expires;		}				# update storage		$cur = $this->store->open();		$this->record->state = $cur->state = 2;		$this->record->token = $cur->token = $this->client;		$this->record->secret = $cur->secret = null;		$this->store->upd($this->record->uid,$cur,$this->config['expiry']);				# Execute a function after acces grant		$this->onGrantAccess();		return true;	}		protected function onGrantAccess()	{		// do what you want in your child class	}		/*********************************/			/* GET wrapper for query */	public function get($url,$parameters=array())	{		$response = $this->query($url,'GET',$parameters);		if ($this->format === 'json' && $this->decode_json)		{			return json_decode($response);		}		return $response;	}		/* POST wrapper for query */	public function post($url,$parameters=array())	{		$response = $this->query($url,'POST',$parameters);		if ($this->format === 'json' && $this->decode_json)		{			return json_decode($response);		}		return $response;	}		/* DELETE wrapper for query */	public function delete($url,$parameters=array())	{		$response = $this->query($url,'DELETE',$parameters);		if ($this->format === 'json' && $this->decode_json)		{			return json_decode($response);		}		return $response;	}		/*  Generic wrapper for query */	public function query($url,$method,$parameters)	{		if (strrpos($url,'https://') !== 0 && strrpos($url,'http://') !== 0)		{			$url = $this->config['api_url'].$url;		}		$parameters[$this->config['query_type']] = $this->client; //?access_token=code				switch ($method)		{			case 'GET':			$url .= '?'.http_build_query($parameters,'','&');			return $this->http($url,'GET');					default:			return $this->http($url,$method,$parameters);		}	}		//!!! Can not use clearbricks netHttp as DELETE method is missing	private function http($url,$method,$postfields=NULL)	{		$this->http_info = array();		$ci = curl_init();				/* Curl settings */		curl_setopt($ci,CURLOPT_USERAGENT,$this->useragent);		curl_setopt($ci,CURLOPT_CONNECTTIMEOUT,$this->connecttimeout);		curl_setopt($ci,CURLOPT_TIMEOUT,$this->timeout);		curl_setopt($ci,CURLOPT_RETURNTRANSFER,TRUE);		curl_setopt($ci,CURLOPT_HTTPHEADER,array('Expect:'));		curl_setopt($ci,CURLOPT_SSL_VERIFYPEER,$this->ssl_verifypeer);		curl_setopt($ci,CURLOPT_HEADERFUNCTION,array($this,'getHeader'));		curl_setopt($ci,CURLOPT_HEADER,FALSE);				switch ($method)		{			case 'POST':			curl_setopt($ci,CURLOPT_POST,TRUE);			if (!empty($postfields))			{				curl_setopt($ci, CURLOPT_POSTFIELDS, $postfields);			}			break;						case 'DELETE':			curl_setopt($ci,CURLOPT_CUSTOMREQUEST,'DELETE');			if (!empty($postfields))			{				$url = "{$url}?{$postfields}";			}		}				curl_setopt($ci,CURLOPT_URL,$url);		$response = curl_exec($ci);		$this->http_code = curl_getinfo($ci,CURLINFO_HTTP_CODE);		$this->http_info = array_merge($this->http_info,curl_getinfo($ci));		$this->http_url = $url;		curl_close ($ci);				return $response;	}		private function getHeader($ch,$header)	{		$i = strpos($header,':');		if (!empty($i))		{			$key = str_replace('-', '_',strtolower(substr($header,0,$i)));			$value = trim(substr($header,$i + 2));			$this->http_header[$key] = $value;		}		return strlen($header);	}}?>